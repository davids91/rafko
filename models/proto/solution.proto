syntax = "proto3";
option cc_enable_arenas = true;

package sparse_net_library;

import "sparse_net.proto";

/**
 * @brief      An intermediate solution as it calculates
 *             a coherent part of a sparse neural network, where locality is maximized.
 *             The arrays inside this structure all have their sizes defined by @internal_neuron_number
 *             and/or the size of @data, which contains the data for the inputs and neurons as well.
 */
message Partial_solution{
  /** ################################################################################################
   * Solution data
   */
  uint32 input_data_size = 1; /* number of used inputs */
  repeated uint32 input_data_synapse_size = 2; /* Input Partition table(==synapse) sizes */
  repeated sint32 input_data_synapse_starts = 3; /* Input partition table starting indexes; negative means input, positive means internal data */
  uint32 internal_neuron_number = 4; /* number of neurons used in this partial solution */
  repeated double weight_table = 5; /* stores the weights paired to @inside_indexes for the inputs of the Neurons; Ranges [0.0,1.0) */

  /** ################################################################################################
   * A representation of the actual neuron to be used in this intermediate solution
   * - sizes are of @internal_neuron_number
   */
  repeated uint32 actual_index = 10; /* Stores the actual index of the Neuron in the sparse_net it calculates the value for
                                     * Indexes are global to @neuron_array under the @SparseNet to be solved */

  /** Parameters each neuron have to post-process their inputs
   */
  repeated transfer_functions neuron_transfer_functions = 11;
  repeated double memory_ratio_index = 12;
  repeated double bias_index = 13;
  repeated uint32 index_synapse_number = 14;
  repeated uint32 weight_synapse_number = 15;

  /** ################################################################################################
   * Partition table(==synapse) storing batches of input indexes for an inner neuron
   * - Every Neuron can have a different number of synapses, their numbers are stored under @index_synapse_number
   * - Positive Neuron synapse inputs are mapped to the order of the Neurons
   * - Negative Neuron Synapse inputs are mapped to the Partial solution input
   * - Since solving the detail is incremental, the start of each Neuron's input synapse index
   *   is determined at runtime, so it doesn't need to be stored
   */
  repeated uint32 inside_index_sizes = 20; /* The size of the inside index synapses. Size is of the summary of the elements in @input_sizes */
  repeated sint32 inside_index_starts = 21; /* Starting indexes of inputs of the Neurons; value range [0 ; @data.size). Size equals @inside_index_sizes */

  /** ################################################################################################
   * Partition table(==synapse) storing batches of input weights for an inner neuron
   * - Every Neuron can have a different number of synapses, their numbers are stored under @weight_synapse_number
   * - Solving the @Partial_solution is based on ondexes, every new index reads in a weight. In case the currently
   *   used weight synapse ends, another synapse starts.
   * - The number of weights shall equal the number of indexes, so the two synapses should end at the
   *   same number of input-weight pairs.
   * - Although @weight_synapse_number is not used while solving the @Partial_solution it can be
   *   used to check wether the above statement holds true
   * - Neuron synapse tables are mapped into an array, in order of the Neurons
   */
  repeated uint32 weight_index_sizes = 22; /* The Sizes of the used Weight synapses for a Neuron. Size is of the summary of the elements in @input_sizes  */
  repeated sint32 weight_index_starts = 23; /* Starting indexes of weights of the above inputs;value range [0.0,1.0]. Size equals @weight_index_sizes */
}

/**
 * @brief      A collection of independent @Partial_solution messages to be executed in parallel.
 *             Each row depends on the previous one, but partial solutions in one row can be solved
 *             in paralell.
 */
message Solution{
  uint32 output_number = 1; /* The number of outputs this solution has */
  uint32 rows = 2;
  uint32 cols = 3;
  repeated Partial_solution partial_solutions = 4;
}
